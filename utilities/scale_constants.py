# Standard library imports
import matplotlib.pyplot as plt
import pandas as pd

# Local imports
from pomsimulator.modules.text_module import Read_csv,Print_logo
from pomsimulator.modules.msce_module import *
from pomsimulator.modules.DataBase import *
from pomsimulator.modules.plotting_module import plot_boxplot_plot

def Internal_Lab_Gen(df, lgkf_dict):
    '''Determines the species having experimental data from the dictionary
    to filter out the DataFrame.
    Args:
        df. Pandas DataFrame containing lgkf values for a set of speciation models.
        lgkf_dict. Dict mapping species' labels to experimental rate constants.
    Returns:
        filt_df. Filtered DataFrame only having lgkf values for species with experimental values.
        int_labels. List of strings, labels of all species with experimental constants.
        Kexp. NumPy array of floats, exp. constant values. 

    '''
    int_labels = list(lgkf_dict.keys())
    filt_df = df.loc[:, int_labels]
    filt_df = filt_df[~filt_df.isna().any(axis=1)]

    Kexp = [lgkf_dict[lab] for lab in int_labels]
    Kexp = np.array(Kexp)

    return filt_df, int_labels, Kexp

def lgKf_scaling(filt_df, Kexp):
    '''Applies linear regression to the whole set of speciation models in the DataFrame against the experimental
    constants, returning a DF of regression parameters for each model.
    Args:
        filt_df. Pandas DataFrame as generated by Internal_Lab_Gen, only having columns for species with exp. constant.
        Kexp. NumPy array of floats, exp. constant values. 
    Returns:
        df2. Pandas DataFrame with slope, intercept, regression coefficient, standard error and rmse for each model.
    '''
    result = filt_df.apply(func=linregress, axis=1, y=Kexp)
    df2 = pd.DataFrame.from_dict(dict(zip(result.index, result.values)), orient="index",
                                 columns=["m", "b", "r", "p", "std_err"])
    a2 = df2.to_numpy()
    arr = filt_df.to_numpy()
    arr_sc = arr * a2[:, 0].reshape(-1, 1) + a2[:, 1].reshape(-1, 1)
    rmse = np.sqrt(np.apply_along_axis(func1d=mean_squared_error, axis=1, arr=arr_sc, y_pred=Kexp))
    df2.loc[:, 'rmse'] = rmse
    return df2

def df_2_boxplot(df,Exp_kf_dict,color=None,box_height=5,ax=None,remove_outliers=False):
    '''Complete workflow to generate boxplot values for computed DFT constants in a dataset
   and plot them in the positions marked by experimental constants
    Args:
        df. Pandas DataFrame containing lgkf values for a set of speciation models.
        Exp_kf_dict. Dict mapping species' labels to experimental rate constants.
        color. String, color specification for matplotlib.
        box_height. Float, height of boxplot for plotting.
        ax. Matplotlib Axis object to put figure in. If None, generate new figure.
        remove_outliers. Boolean, if True, filter out all the outliers in the boxplot.
    Returns:
        boxplot_dict. Dict indexed by labels of species with all information for each
        boxplot as produced by get_boxplot_data
        Produces figure with all boxplots.
    '''
    if not ax:
        fig,ax = plt.subplots()
    species = df.columns
    boxplot_dict = {}
    for ii,sp in enumerate(species):
        arr = df.loc[:,sp].to_numpy()
        y_pos = Exp_kf_dict[sp]
        col = color
        ax_ii,boxplot = plot_boxplot_plot(arr,y_pos,col,box_height,sp,ax=ax,remove_outliers=remove_outliers)
        boxplot_dict[sp] = boxplot
    return boxplot_dict

def plot_best_mods(lgkf_df,sorted_params_df,Kexp,plot_shape=(2,2)):
    '''Auxiliary function to simplify the generation of best speciation models,
    using the information from regressions in lgKf_scaling.
    Args:
        lgkf_df. Pandas DataFrame containing lgkf values for a set of speciation models.
        sorted_params_df. Pandas DataFrame with slope, intercept, regression coefficient, standard error and rmse for each model
        which has been sorted by a parameter of interest (e.g. by rmse to plot best models)
        Kexp. NumPy array with experimental values for rate constants.
        plot_shape. Tuple of integers, marking the no. of panes in the plot. 
    Returns:
        fig,ax. Matplotlib Figure and Axis objects.
    '''
    fig, axes = plt.subplots(plot_shape[0], plot_shape[1], sharex=True, sharey=True)
    ax = axes.flatten()
    fig.set_size_inches(4*plot_shape[1],4*plot_shape[0])
    orange = '#e86e00ff'
    blue = '#202252ff'
    Nplots = plot_shape[0]*plot_shape[1]
    for ii in range(Nplots):
        mod_idx = sorted_params_df.index[ii]
        lgkf = lgkf_df.loc[mod_idx,:]
        pars = sorted_params_df.iloc[ii,:]
        m = pars.loc["m"]
        b = pars.loc["b"]
        r2 = (pars.loc["r"])**2
        rmse = pars.loc["rmse"]
        lgkf_scaled = lgkf * m + b
    ##############################################FIGURA 0,0 ###############################################################
        ax[ii].set_ylabel("Experimental Constants " + "$(pK_{f}^{Exp})$", fontsize=12)
        ax[ii].set_xlabel("DFT Constants " + "$(pK_{f}^{DFT})$", fontsize=12)
        ax[ii].plot(lgkf,lgkf_scaled,'-',color=orange)
        ax[ii].plot(lgkf, Kexp, '.', markersize=11, color=blue)
        ax[ii].text(160, 60, "y=%.2fx+(%.2f) and r=%.2f"%(m,b,r2), fontsize=10)
        ax[ii].text(140, 140, "RMSE = %.2f"%rmse, fontsize=10)
    plt.tight_layout()
    return fig,ax

def LinearScaling(path, Labels, d_Cruy, scaling_mode="best_rmse", output_scaling="regression_output.csv",Metal=None):


    '''Wrapper function to apply linear scaling to a set of lgkf values in a
    CSV file.
    Args:
        path. String, path to the file to read constants from.
        Labels. List of strings, complete list of labels for the system being treated.
        d_Cruy. Dict mapping species' labels to experimental rate constants.
        scaling_mode. String, can be:
            - best_rmse. Gather the model with the lowest RMSE and select its m, b parameters.
            - average. Get the average m and b parameters among all models. 
        universal_scaling. Boolean, if True consider boxplots for all regressions, else
        only plot best models.
    Returns:    
        None: generates image and output files.
            - regression_output.csv. CSV file with the parameters of all individual regressions.
            - scaling_params_PMo.pomsim. File containing the slope and intercept to be used in speciation.
    '''
    lgkf_df = Read_csv(path,Labels)
    _lgkf_df,int_labels2,Kexp = Internal_Lab_Gen(lgkf_df,d_Cruy)

    # Flag to perform all regressions
    all_regressions = scaling_mode in ["best_rmse","average"]
    
    if all_regressions:
        scaling_params_df = lgKf_scaling(_lgkf_df,Kexp)
        # Sort the array and save it
        scaling_params_sorted = scaling_params_df.sort_values(by="rmse")
        scaling_params_sorted.to_csv(output_scaling)
        best_model_idx = int(scaling_params_sorted.index[0])

    if scaling_mode == "average":
        best_model_idx = -1
        rmse_average = scaling_params_df["rmse"].mean()
        slope_average = scaling_params_df["m"].mean()
        intercept_average = scaling_params_df["b"].mean()

        # Printing average of the list
        print("RMSE average =", round(rmse_average, 2)," Minimum RMSE =",round(scaling_params_df["rmse"].min(),2))
        print("Slope average =", round(slope_average, 2))
        print("Intercept average =", round(intercept_average, 2))

        fig,ax = plt.subplots(1,1)
        boxplot = df_2_boxplot(_lgkf_df,d_Cruy,color='tab:blue',ax=ax)

        m = slope_average
        b0 = intercept_average 

        xvals = np.linspace(_lgkf_df.min().min(), _lgkf_df.max().max(), 100)
        yvals = m * xvals + b0
        ax.plot(xvals, yvals, color='deeppink', zorder=0, alpha=0.3)

        ax.annotate('y = %.2fx + %.2f' % (m, b0), (_lgkf_df.min().min(), 150))

    elif scaling_mode == "best_rmse":
        best = scaling_params_sorted.iloc[0,:]
        m = best.m
        b0 = best.b 
        fig,ax = plot_best_mods(_lgkf_df, scaling_params_sorted, Kexp, plot_shape=(2, 2))
        
    elif scaling_mode == "medians":
        best_model_idx = -1
        fig,ax = plt.subplots(1,1,figsize=(6,6))
        boxplot = df_2_boxplot(_lgkf_df,d_Cruy,color='tab:blue',ax=ax)

        Kf_dft_median = [boxplot[k]["median"] for k in int_labels2]
        Kf_exp = [d_Cruy[k] for k in int_labels2]
        reg_param = linregress(Kf_dft_median, Kf_exp)

        m = reg_param.slope
        b0 = reg_param.intercept
        r = reg_param.rvalue
        merr = reg_param.stderr
        berr = reg_param.intercept_stderr
        xvals = np.linspace(_lgkf_df.min().min(), _lgkf_df.max().max(), 100)
        yvals = m * xvals + b0
        ax.plot(xvals, yvals, color='deeppink', zorder=0, alpha=0.3)
        ax.fill_between(xvals, yvals + berr, yvals - berr, alpha=0.15, color='deeppink', zorder=0)

        ax.annotate('y = %.2fx + %.2f (+- %.2f, %.2f)' % (m, b0, merr, berr), (_lgkf_df.min().min(), 150))
        ax.annotate('r$^2$ = %.4f' % (r ** 2), (_lgkf_df.min().min(), 140))

    # Write to file
    if Metal == None:
        outfile = "../outputs/scaling_params.pomsim"
    else:
        outfile = "../outputs/scaling_params_%s.pomsim" % Metal
    with open(outfile, "w") as fout:
        header = "%10s %6s %6s %12s\n" % ("Mode","m","b","best")
        vals = "%10s %6.4f %6.4f %12d \n" % (scaling_mode,m,b0,best_model_idx)
        fout.write(header + vals)
        
    return fig,ax


def main():
    metal = "W"
    Labels = Labels_W
    ExpDict = Rosantsev_W12_I01_05I
    lgkf_file = "../outputs/logkf_W.txt"
    scaling_params_file = "../outputs/regression_output.csv"

    Print_logo()
    fig,ax = LinearScaling(lgkf_file, Labels, ExpDict, scaling_mode="best_rmse",output_scaling=scaling_params_file,Metal=metal)
    plt.savefig("../outputs/scaling_plot_best_model.png",dpi=300)
    plt.show()

    #LinearScaling(lgkf_file, Labels, ExpDict, scaling_mode="average")
    #plt.savefig("scaling_plot_average.png",dpi=300)

if __name__ == '__main__':
    main()
